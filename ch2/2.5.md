### Identity

```js
// 位x.x

const identity = x => x
```

###  Self-application Function
An interesting one! The body expression *is* the function application.
```js
// 位s.(s, s)

const selfAppFn = s => s(s)
```

Applying `identity` to it:

```js
// (位x.x 位s.(s, s))

identity(
  selfAppFn
) // => selfAppFn
```

Now the reverse, applying `selfAppFn` to `identity`:

```js
// (位s.(s, s) 位x.x)

selfAppFn(
  identity
) // => identity
```

That one is a little less obvious, let's break it into steps.

1.) `identity` replaces `s` in `selfAppFn`: `(位x.x 位x.x)`.
2.) Since the argument exptression is now `identity`, that gets passed to `identity`.
3.) `// => identtity`

Hence the name, self-application. 

Let's go full inception and self apply the self-applying function:

```js
// (位s.(s s) 位s.(s s))

selfAppFn(selfAppFn) // => Uncaught RangeError: Maximum call stack size exceeded
```

But why . Let's break it down into steps again:

1.) `selfAppFn` replaces `s` in `selfAppFn`: `(位s.(s, s) 位s.(s, s))`.
2.) Since the argument exptression is now `selfAppFn`, that gets passed to `selfAppFn`.
3.) `// => selfAppFn(selfAppFn)`
4.) Wait that's what we started with! 

### Function application function

```js
// 位fn.位arg.(fn arg)

fn => arg => fn(arg)
```
